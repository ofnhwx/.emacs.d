#+TITLE: config/features.org
#+STARTUP: overview

* プロジェクト設定
** プロジェクトルートの取得
   #+begin_src emacs-lisp
   (setq e:project-root-mark '(".git/" ".hg/" ".svn/" ".git"))
   (defun e:project-root (dir)
     "指定した DIR のプロジェクトルートを返す."
     (let* ((dir (file-name-directory (expand-file-name dir)))
            (candidates (mapcar (lambda (name) (locate-dominating-file dir name)) e:project-root-mark))
            (root (car (sort candidates (lambda (this other) (> (length this) (length other)))))))
       (if root (abbreviate-file-name root) nil)))
   #+end_src
** プロジェクト名の取得
   #+begin_src emacs-lisp
   (defun e:project-name (root)
     "指定した ROOT のプロジェクトの名前をいい感じに返す."
     (let* ((root (directory-file-name root))
            (name (file-name-nondirectory root))
            (parent (e:project-root root)))
       (if parent
           (concat (e:project-name parent) "/" name)
         name)))
   #+end_src
* ヘッダーライン
** ファイル用
   #+begin_src emacs-lisp
   (defvar e:header-line-for-files-cache (make-hash-table :test 'equal))
   (defun e:header-line-for-files-format-internal (path &optional refname)
     (let* ((separator-left  #'powerline-wave-right)
            (separator-right #'powerline-wave-left)
            (tramp (file-remote-p path))
            (proot (e:project-root path))
            (pname (and proot (e:project-name proot)))
            (file  (f-filename path))
            (dir   (f-short (file-name-directory path)))
            (lhs nil)
            (rhs nil))
       (when proot
         (setq dir (s-replace proot "" dir))
         (setq lhs (-snoc lhs
                          (powerline-raw (concat pname " ") 'powerline-active1 'l)
                          (funcall separator-left 'powerline-active1 'powerline-inactive1))))
       (cond
        (tramp
         (setq dir (s-replace tramp "" dir))
         (setq rhs (-snoc rhs
                          (funcall separator-right 'powerline-inactive1 'powerline-active1)
                          (powerline-raw (concat " " (string-trim-right tramp ":")) 'powerline-active1 'r))))
        (refname
         (setq rhs (-snoc rhs
                          (funcall separator-right 'powerline-inactive1 'powerline-active1)
                          (powerline-raw (concat " " refname) 'powerline-active1 'r)))))
       (setq lhs (-snoc lhs
                        (powerline-raw dir 'mode-line 'l)
                        (powerline-raw file 'font-lock-keyword-face)))
       (concat (powerline-render lhs)
               (powerline-fill 'mode-line (powerline-width rhs))
               (powerline-render rhs))))
   (defun e:header-line-for-files-format ()
     "ファイル用のヘッダーラインのフォーマット"
     (let* ((path    (or (f-long (e:current-buffer-file-name)) ""))
            (refname (e:current-buffer-refname))
            (key     (concat path (or refname ""))))
       (or (gethash key e:header-line-for-files-cache)
           (puthash key (e:header-line-for-files-format-internal path refname) e:header-line-for-files-cache))))
   (defun e:setup-header-line-for-files ()
     "ファイル用のヘッダーラインの設定"
     (set-face-attribute 'header-line nil :inherit 'mode-line)
     (setq-local spaceline-buffer-id-p nil)
     (setq-local header-line-format
                 '((:eval (e:header-line-for-files-format)))))
   #+end_src
* コマンドの結果を取得
** コマンドの結果を文字列で取得
   #+begin_src emacs-lisp
   (defun e:shell-command-to-string (command)
     "コマンドの結果を文字列で取得."
     (string-trim (shell-command-to-string command)))
   #+end_src
** コマンドの結果をリストで取得
   #+begin_src emacs-lisp
   (defun e:shell-command-to-list (command)
     "コマンドの結果をリストで取得."
     (split-string (e:shell-command-to-string command) "\n"))
   #+end_src
* その他の便利な関数
** 認証情報の取得
   #+begin_src emacs-lisp
   (defun e:auth-source-get (property &rest spec)
     "認証情報から SPEC に一致する項目の PROPERTY を取得する."
     (let ((plist (car (apply 'auth-source-search spec)))
           (pkey (intern (format ":%s" property))))
       (when plist
         (plist-get plist pkey))))
   #+end_src
** リストから指定された順番の要素を削除
   #+begin_src emacs-lisp
   (defun e:remove-nth (n list)
     "N 番目の要素を LIST から取り除いて返す."
     (if (or (zerop n) (null list))
         (cdr list)
       (cons (car list) (e:remove-nth (1- n) (cdr list)))))
   #+end_src
** パスの短縮
   #+begin_src emacs-lisp
   (defun e:shorten (path &optional max separator omit)
     "指定された FILENAME を MAX 以下の長さに短縮する.
     パスの区切り文字は SEPARATOR, 短縮時の省略表示を OMIT で指定する."
     (let* ((max (or max (window-width)))
            (separator (or separator "/"))
            (omit (or omit "..."))
            (parts (split-string (abbreviate-file-name path) separator))
            (length (length (abbreviate-file-name path)))
            (target (if (string-empty-p (car parts)) 3 2))
            (min-parts (+ target 3)))
       (when (and (> length max)
                  (> (length parts) min-parts))
         (setq length (+ length (length omit) (- (length (nth target parts)))))
         (setf (nth target parts) omit)
         (setq target (+ target 1))
         (while (and (> length max)
                     (> (length parts) min-parts))
           (setq length (- length (length (nth target parts)) 1))
           (setq parts (e:remove-nth target parts))))
       (string-join parts separator)))
   #+end_src
** メジャーモードの取得
   #+begin_src emacs-lisp
   (defun e:major-mode (&optional buffer)
     (buffer-local-value 'major-mode (or buffer (current-buffer))))
   #+end_src
** いい感じにファイル名を取得
   #+begin_src emacs-lisp
   (defun e:current-buffer-file-name ()
     (or buffer-file-name
         (bound-and-true-p magit-buffer-file-name)))
   #+end_src
** いい感じに Git の参照名を取得
   #+begin_src emacs-lisp
   (defun e:current-buffer-refname ()
     (if (bound-and-true-p magit-buffer-refname)
         (format "<%s>" magit-buffer-refname)))
   #+end_src
